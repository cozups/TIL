# 스레드 / blocking / 자바스크립트 실행 환경

스레드 = 일하는 사람

# 싱글 스레드

한 사람이 주어진 작업을 하나씩 처리하는 방식

## 장점

- 경쟁 상태가 없다.
- 코드 복잡도가 상대적으로 낮다.

## 단점

- 병렬처리보다 평균적으로 성능이 떨어진다.

# 멀티 스레드

여러 사람이 주어진 작업을 처리하는 방식

## 장점

- 싱글 스레드보다 성능이 매우 좋다.

## 단점

- 경쟁 상태를 고려해야 함. (코드 복잡도가 높다)
    - lock 또는 mutex를 걸어야 예상치 못한 오류를 피할 수 있다.
    

자바스크립트는 싱글 스레드로 작동하는 언어이다.

싱글스레드인 상황에서 성능을 극대화 하기 위해 **비동기 처리 방식**을 채용한다.

# Blocking

하나의 작업을 마치고 나서 다음 작업을 실행하는 순차적 방식

- 하나의 작업이 길어지면 다음 작업이 지연된다.

동기와 거의 비슷

# Non-blocking

하나의 작업을 마치지 않아도 다음 작업을 실행하는 방식

- 작업이 길어져도 다음 작업이 지연되는 문제가 발생하지 않는다.

보통 결과 값을 `return` 문으로 바로 받지 못하며 콜백 함수를 통해 받는 경우가 많다.

- 단, `Promise` 의 등장으로 콜백함수가 아닌 다른 방식으로 받게 됨.

비동기와 거의 비슷

## 자바스크립트 비동기 동작 원리

자바스크립트는 런타임에 비동기를 지원하지 않는다.

동시성을 보장하는 **비동기, 논블로킹 작업**은 자바스크립트 엔진을 구동하는 **런타임 환경(브라우저, Nodejs)**에서 지원한다.

- 자바스크립트는 코드를 실행할 뿐.. 런타임 환경에서 이벤트를 스케줄링하고 비동기 작업을 처리한다

자바스크립트는 싱글스레드이기 때문에 잘못 설계하거나 http 요청을 동기로 수행하는 경우, 로딩 상태를 겪게 되며 심하면 무한로딩에 빠진다.

따라서 오래 걸리는 요청 작업을 Web API(브라우저)에게 넘김으로써 다른 코드들을 실행할 수 있게된다.

1. 코드가 호출 스택에 쌓이고 실행되면, 자바스크립트 엔진은 비동기 작업을 Web API에게 위임한다.
2. Web API는 해당 작업을 수행하고 콜백함수를 이벤트 루프를 통해 콜백 큐에 전달한다.
3. 이벤트 루프는 콜 스택에 쌓인 함수가 없을 때, 콜백 큐에서 대기하던 콜백함수를 콜 스택으로 넘긴다.
4. 콜 스택에 쌓인 콜백함수를 실행하고 콜 스택에서 제거한다.

# 자바스크립트 실행 환경

- 자바스크립트 엔진
- 이벤트 루프 + 큐
- 외부 API

## 자바스크립트 엔진

자바스크립트 코드를 읽어 해석하고 작업을 수행한다.

**엔진 자체는 작업 수행만 할 뿐 비동기/동기와는 상관이 없다.**

- V8, SpiderMonkey, JavascriptCore ...

## 이벤트 루프 + 큐

자바스크립트 코드가 비동기 실행될 수 있도록 도와주는 중심적인 역할

### 이벤트 루프

- 큐에 쌓인 콜백 함수들을 꺼내서 자바스크립트 엔진에게 전달한다.
- 엔진은 함수들을 전달받은 순서대로 실행한다.
- Node.js의 libuv
- 

### 큐

- 비동기 작업을 마친 후 실행될 콜백 함수가 쌓이는 곳
- Task queue(MacroTask queue), MicroTask queue

## 외부 API

비동기/동기 작업들의 묶음

비동기 작업은 주로 외부 API를 통해 실행된다.

- 작업을 마쳤을 경우 실행되는 콜백 함수를 해당 API의 매개변수로 전달한다.
- 작업이 완료되면 큐에 콜백함수를 등록한다.
- setTimeout, setInterval, fetch, console, fs, path

# 자바스크립트에서 비동기 작업을 수행하는 방식

## 콜백 패턴

비동기 작업들은 `return` 이 아닌 별도의 결과를 반환하는 방식이 필요 했음

콜백 패턴이 없었다면 비동기 작업 완료 여부를 수동적으로 확인했어야 함

→ 프로그램 측면에서 매우 낭비적인 행위

자바스크립트는 함수를 객체로 취급하기 때문에 가능한 일

### Problem: 콜백 지옥

![https://kyj7337.github.io/static/7e4b51c526994565ce722498f17f0178/f6c57/hell.jpg](https://kyj7337.github.io/static/7e4b51c526994565ce722498f17f0178/f6c57/hell.jpg)

중첩 함수를 무차별적으로 쓰면 가로로 코드가 길어진다.

## Promise 패턴

콜백 지옥에서 벗어나기 위한 움직임

then, catch, finally를 통해 비동기 함수를 일관성 있는 형식으로 관리한다.

코드 가독성이 높아지며 chaining 기법을 사용할 수 있다.

### Problem

- 초기 호환성 문제가 있다.
- 연결되는 비동기 함수가 많아질수록 then 체인이 길어진다.
- JS의 비동기 환경을 처음 접하는 사람들에게는 복잡한 개념이다.

## async/await 패턴

비동기 코드를 동기 코드처럼 볼 수 있다.

가독성이 향상되며 코드 흐름을 보기 쉽다.

Promise로 되어있는 비동기 함수들을 async/await만 붙여 손쉽게 코드를 치환할 수 있다.