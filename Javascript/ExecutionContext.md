# 실행 컨텍스트 (Execution Context)

코드들이 실행되기 위한 환경

- this
  - global scope에서는 `window`
- Variable Object
  - 변수
  - 파라미터(parameter), 인수(arguments)
  - 함수 선언 (표현식 x)
  - Variable Object는 실행 컨텍스트의 프로퍼티이기 때문에 값을 갖는데, 전역 코드 실행시 생성되는 전역 컨텍스트의 경우와 함수를 실행할 때 생성되는 함수 컨텍스트의 경우, 가리키는 객체가 다르다.
    - 전역 코드와 함수의 내용이 다르기 때문
    - 전역 코드에는 매개변수가 없지만 함수에는 매개변수가 있다.
- Scope chain
  - `Scope`: 코드가 현재 실행되는 환경, 맥락
  - 전역 객체와 함수의 스코프의 레퍼런스를 저장하고 있다.
  - 스코프 체인은 **실행 컨텍스트가 참조할 수 있는 변수, 함수 선언 등의 정보를 담고 있는 리스트**를 가리킨다.
  - 자바스크립트 엔진은 스코프 체인을 통해 렉시컬 스코프를 파악한다.
    - 렉시컬 스코프: 함수를 어디서 선언하였는지에 따라 상위 스코프를 결정하는 것
  - 상위 함수, 전역 스코프 등을 참조할 수 있는 이유가 스코프 체인이 검색을 하기 때문이다.
  - (하위 -> 상위 -> 전역) 참조에 실패한다면 스코프 체인에 담겨진 순서대로 계속해서 이어가는 것이다.
  - 검색에 실패하게 된다면 정의되지 않은 변수에 접근하는 것이기 때문에 에러를 발생시킨다.

<br>

## Execution Context의 종류

![globalcontext](https://poiemaweb.com/img/ec-vo-global.png)

- Global Context

  함수 안에서 실행되는 코드가 아니라면 전부 전역 컨텍스트에서 실행된다.

<br>

![functionalcontext](https://poiemaweb.com/img/ec-vo-foo.png)

- Functional Context

  선언된 함수가 호출될 때를 기점으로 생성된다.

  함수의 모든 동작이 끝나면 소멸된다. (Closure를 사용한다면 소멸하지 않고 이용할 수 있다.)

<br>

## Call Stack

```
var x = 'xxx';

function foo () {
  var y = 'yyy';

  function bar () {
    var z = 'zzz';
    console.log(x + y + z);
  }
  bar();
}
foo();
```

이런 코드가 있다고 하자.

![call stack](https://poiemaweb.com/img/ec_1.png)
위 코드를 실행하면 실행 컨텍스트는 이렇게 스택에 쌓이게 된다.

새로운 컨텍스트가 생성될 때 제어권도 같이 넘어가게 된다.

1. 컨트롤이 실행 가능한 코드로 이동하면 논리적 스택 구조를 가지는 새로운 실행 컨텍스트 스택이 생성된다. 스택은 LIFO(Last In First Out, 후입 선출)의 구조를 가지는 나열 구조이다.

2. 전역 코드(Global code)로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때(웹 페이지에서 나가거나 브라우저를 닫을 때)까지 유지된다.

3. 함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며 직전에 실행된 코드 블록의 실행 컨텍스트 위에 쌓인다.

4. 함수 실행이 끝나면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환한다.

Call Stack은 깊이 제한이 있다. => 넘어가는 경우 Stack Overflow
